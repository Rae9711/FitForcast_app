/// Generate a TypeScript-ready Prisma client for interacting with the database.
generator client {
  provider = "prisma-client-js"
}

/// Configure the Postgres datasource and pull connection details from the environment.
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// Enumerations codify our domain-specific option lists so inputs remain type-safe.
enum LogEntryType {
  workout
  meal
}

enum FeelingWhen {
  pre
  post
}

enum ActivityIntensity {
  low
  medium
  high
}

enum MealType {
  breakfast
  lunch
  dinner
  snack
}

enum BaselineScope {
  workout
  meal
  mood
}

/// Users represent FitForecast accounts and own the downstream records.
model User {
  id              String           @id @default(uuid())
  email           String           @unique
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  entries         LogEntry[]
  baselineMetrics BaselineMetric[]
  insights        Insight[]
}

/// LogEntry stores the raw text and metadata submitted by the user.
model LogEntry {
  id          String         @id @default(uuid())
  userId      String
  user        User           @relation(fields: [userId], references: [id])
  type        LogEntryType
  rawText     String
  occurredAt  DateTime
  createdAt   DateTime       @default(now())
  feelings    FeelingEntry[]
  parsedEntry ParsedEntry?

  @@index([userId, occurredAt])
}

/// FeelingEntry captures pre/post mood check-ins tied to a log entry.
model FeelingEntry {
  id         String      @id @default(uuid())
  logEntryId String
  logEntry   LogEntry    @relation(fields: [logEntryId], references: [id])
  when       FeelingWhen
  valence    Int
  energy     Int
  stress     Int
  notes      String?
  createdAt  DateTime    @default(now())

  @@index([logEntryId])
}

/// ParsedEntry holds optional NLP enrichment derived from the raw text.
model ParsedEntry {
  id            String             @id @default(uuid())
  logEntryId    String             @unique
  logEntry      LogEntry           @relation(fields: [logEntryId], references: [id])
  activityType  String?
  durationMin   Int?
  intensity     ActivityIntensity?
  mealType      MealType?
  foodTags      String[]           @default([])
  createdAt     DateTime           @default(now())
}

/// BaselineMetric stores rolling aggregates the insights engine consumes.
model BaselineMetric {
  id          String        @id @default(uuid())
  userId      String
  user        User          @relation(fields: [userId], references: [id])
  scope       BaselineScope
  metric      String
  value       Float
  windowDays  Int
  dataPoints  Int
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@index([userId, scope, windowDays])
  @@unique([userId, scope, metric, windowDays], name: "user_scope_metric_window")
}

/// Insight rows represent surfaced recommendations backed by rule metadata.
model Insight {
  id              String   @id @default(uuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id])
  type            String
  summary         String
  supportingStats Json
  ruleName        String
  createdAt       DateTime @default(now())
  isActive        Boolean  @default(true)

  @@index([userId, isActive])
  @@unique([userId, type, ruleName], name: "userId_type_ruleName")
}
